#summary Security

== Introduction ==
The <tt>Security</tt> package provides a security framework that allows
an application to use OpenID or OAuth security frameworks.  This security
framework was first developed within the Ada Server Faces project.
This package defines abstractions that are close or similar to Java
security package.

The security framework uses the following abstractions:

=== Policy and policy manager ===
The <tt>Policy</tt> defines and implements the set of security rules that specify how to
protect the system or resources.  The <tt>Policy_Manager</tt> maintains the security policies.

=== Principal ===
The <tt>Principal</tt> is the entity that can be authenticated.  A principal is obtained
after successful authentication of a user or of a system through an authorization process.
The OpenID or OAuth authentication processes generate such security principal.

=== Permission ===
The <tt>Permission</tt> represents an access to a system or application resource.
A permission is checked by using the security policy manager.  The policy manager uses a
security controller to enforce the permission.

=== Security Context ===
The <tt>Security_Context</tt> holds the contextual information that the security controller
can use to verify the permission.  The security context is associated with a principal and
a set of policy context.

== Overview ==
An application will create a security policy manager and register one or several security
policies.  The framework defines a simple role based security policy and an URL security
policy intended to provide security in web applications.  The security policy manager reads
some security policy configuration file which allows the security policies to configure
and create the security controllers.  These controllers will enforce the security according
to the application security rules.  All these components (yellow) are built only once when
an application starts.

A user is authenticated through an authentication system which creates a <tt>Principal</tt>
instance that identifies the user (green).  The security framework provides two authentication
systems: OpenID and OAuth.

[http://ada-security.googlecode.com/svn/wiki/ModelOverview.png]

When a permission must be enforced, a security context is created and linked to the
<tt>Principal</tt> instance.  Additional security policy context can be added depending on
the application context.  To check the permission, the security policy manager is called
and it will ask a security controller to verify the permission.

The framework allows an application to plug its own security policy, its own policy context,
its own principal and authentication mechanism.

== OpenID ==
The <b>Security.Openid</b> package implements an authentication framework based
on OpenID 2.0.

See OpenID Authentication 2.0 - Final
http://openid.net/specs/openid-authentication-2_0.html

The authentication process is the following:

  * The <b>Initialize</b> procedure is called to configure the OpenID realm and set the OpenID return callback CB.
  * The <b>Discover</b> procedure is called to retrieve from the OpenID provider the XRDS stream and identify the provider.  An <b>End_Point</b> is returned.
  * The <b>Associate</b> procedure is called to make the association with the <b>End_Point</b>. The <b>Association</b> record holds session, and authentication.
  * The <b>Get_Authentication_URL</b> builds the provider OpenID authentication URL for the association.
  * The application should redirected the user to the authentication URL.
  * The OpenID provider authenticate the user and redirects the user to the callback CB.
  * The association is decoded from the callback parameter.
  * The <b>Verify</b> procedure is called with the association to check the result and obtain the authentication results.

There are basically two steps that an application must implement.

[http://ada-security.googlecode.com/svn/wiki/OpenID.png]

== Discovery: creating the authentication URL ==
The first step is to create an authentication URL to which the user must be redirected.
In this step, we have to create an OpenId manager, discover the OpenID provider,
do the association and get an <b>End_Point</b>.

{{{
  Mgr   : Openid.Manager;
  OP    : Openid.End_Point;
  Assoc : constant Association_Access := new Association;
}}}

The

{{{
  Server.Initialize (Mgr);
  Mgr.Discover (Provider, OP);  --  Yadis discovery (get the XRDS file).
  Mgr.Associate (OP, Assoc.all);--  Associate and get an end-point with a key.
}}}

After this first step, you must manage to save the association in the HTTP session.
Then you must redirect to the authentication URL that is obtained by using:

{{{
  Auth_URL : constant String := Mgr.Get_Authentication_URL (OP, Assoc.all);
}}}

== Verify: acknowledge the authentication in the callback URL ==
The second step is done when the user has finished the authentication successfully or not.
For this step, the application must get back the association that was saved in the session.
It must also prepare a parameters object that allows the OpenID framework to get the
URI parameters from the return callback.

{{{
  Mgr     : Openid.Manager;
  Assoc   : Association_Access := ...;  --  Get the association saved in the session.
  Auth    : Openid.Authentication;
  Params  : Auth_Params;
}}}

The OpenID manager must be initialized and the <b>Verify</b> procedure is called with
the association, parameters and the authentication result.  The <b>Get_Status</b> function
must be used to check that the authentication succeeded.

{{{
  Server.Initialize (Mgr);
  Mgr.Verify (Assoc.all, Params, Auth);
  if Openid.Get_Status (Auth) /= Openid.AUTHENTICATED then ...  -- Failure.


}}}
== OAuth ==
The <b>Security.OAuth</b> package defines and implements the OAuth 2.0 authorization
framework as defined by the IETF working group.
See http://tools.ietf.org/html/draft-ietf-oauth-v2-26
== Security Context ==
The security context provides contextual information for a security controller to
verify that a permission is granted.
This security context is used as follows:

  * An instance of the security context is declared within a function/procedure as a local variable

  * This instance will be associated with the current thread through a task attribute

  * The security context is populated with information to identify the current user, his roles, permissions and other information that could be used by security controllers

  * To verify a permission, the current security context is retrieved and the <b>Has_Permission</b> operation is called,

  * The <b>Has_Permission</b> will first look in a small cache stored in the security context.

  * When not present in the cache, it will use the security manager to find the security controller associated with the permission to verify

  * The security controller will be called with the security context to check the permission. The whole job of checking the permission is done by the security controller. The security controller retrieves information from the security context to decide whether the permission is granted or not.

  * The result produced by the security controller is then saved in the local cache.

== Security Controller ==
The <b>Security.Controllers</b> package defines the security controller used to
verify that a given permission is granted.  A security controller uses the security
context and other controller specific and internal data to verify that the permission
is granted.

To implement a new security controller, one must:

  * Define a type that implements the <b>Controller</b> interface with the <b>Has_Permission</b> operation
  * Write a function to allocate instances of the given <b>Controller</b> type
  * Register the function under a unique name by using <b>Register_Controller</b>

Security controller instances are created when the security policy rules are parsed.
These instances are shared across possibly several concurrent requests.

----
[http://code.google.com/p/ada-gen Generated by Dynamo] _from security.ads_
