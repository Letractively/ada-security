#summary Security

== Introduction ==
The <tt>Security</tt> package provides security frameworks that allows
an application to use OpenID or OAuth security frameworks.  This security
framework was first developed within the Ada Server Faces project.
This package defines abstractions that are close or similar to Java
security package.

== Permissions ==
The <b>Security.Permissions</b> package defines the different permissions that can be
checked by the access control manager.

=== Principal ===
The <tt>Principal</tt> is the entity that can be authenticated.  A principal is obtained
after successful authentication of a user or of a system through an authorization process.
The OpenID or OAuth authentication processes generate such security principal.

=== Permission ===
The <tt>Permission</tt> represents an access to a system or application resource.

== OpenID ==
The <b>Security.Openid</b> package implements an authentication framework based
on OpenID 2.0.

See OpenID Authentication 2.0 - Final
http://openid.net/specs/openid-authentication-2_0.html
== OAuth ==
The <b>Security.OAuth</b> package defines and implements the OAuth 2.0 authorization
framework as defined by the IETF working group.
See http://tools.ietf.org/html/draft-ietf-oauth-v2-26
== Security Context ==
The security context provides contextual information for a security controller to
verify that a permission is granted.
This security context is used as follows:

 * An instance of the security context is declared within a function/procedure as
 a local variable
 * This instance will be associated with the current thread through a task attribute
 * The security context is populated with information to identify the current user,
 his roles, permissions and other information that could be used by security controllers
 * To verify a permission, the current security context is retrieved and the
 <b>Has_Permission</b> operation is called,
 * The <b>Has_Permission<b> will first look in a small cache stored in the security context.
 * When not present in the cache, it will use the security manager to find the
 security controller associated with the permission to verify
 * The security controller will be called with the security context to check the permission.
 The whole job of checking the permission is done by the security controller.
 The security controller retrieves information from the security context to decide
 whether the permission is granted or not.
 * The result produced by the security controller is then saved in the local cache.

== Security Controller ==
The <b>Security.Controllers</b> package defines the security controller used to
verify that a given permission is granted.  A security controller uses the security
context and other controller specific and internal data to verify that the permission
is granted.

To implement a new security controller, one must:

 * Define a type that implements the <b>Controller</b> interface with the
{{{
   <b>Has_Permission</b> operation
 * Write a function to allocate instances of the given <b>Controller</b> type
 * Register the function under a unique name by using <b>Register_Controller</b>
}}}

Security controller instances are created when the security policy rules are parsed.
These instances are shared across possibly several concurrent requests.

----
[http://code.google.com/p/ada-gen Generated by Dynamo] _from security.ads_
